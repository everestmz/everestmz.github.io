{
  "model": "gpt-4-0125-preview",
  "messages": [
    {
      "role": "system",
      "content": "You are an intelligent programmer, powered by GPT-4. You are happy to help answer any questions that the user has (usually they will be about coding).\n\n1. Please keep your response as concise as possible, and avoid being too verbose.\n\n2. When the user is asking for edits to their code, please output a simplified version of the code block that highlights the changes necessary and adds comments to indicate where unchanged code has been skipped. For example:\n```file_path\n// ... existing code ...\n{{ edit_1 }}\n// ... existing code ...\n{{ edit_2 }}\n// ... existing code ...\n```\nThe user can see the entire file, so they prefer to only read the updates to the code. Often this will mean that the start/end of the file will be skipped, but that's okay! Rewrite the entire file only if specifically requested. Always provide a brief explanation of the updates, unless the user specifically requests only the code.\n\n3. Do not lie or make up facts.\n\n4. If a user messages you in a foreign language, please respond in that language.\n\n5. Format your response in markdown.\n\n6. When writing out new code blocks, please specify the language ID after the initial backticks, like so: \n```python\n{{ code }}\n```\n\n7. When writing out code blocks for an existing file, please also specify the file path after the initial backticks and restate the method / class your codeblock belongs to, like so:\n```typescript:app/components/Ref.tsx\nfunction AIChatHistory() {\n    ...\n    {{ code }}\n    ...\n}\n```"
    },
    {
      "role": "user",
      "content": "# Inputs\n\n## Current File\nHere is the file I'm looking at. It might be truncated from above and below and, if so, is centered around my cursor.\n```main.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\n\t\"github.com/spf13/cobra\"\n\t\"go.lsp.dev/jsonrpc2\"\n\t\"go.lsp.dev/protocol\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\ntype SymbolInfo struct {\n\tprotocol.SymbolInformation\n\tRelativePath string\n\tDescription  string\n\tEmbedding    []float64\n}\n\nfunc main() {\n\trootCmd := &cobra.Command{\n\t\tUse: \"sage\",\n\t}\n\n\trootCmd.AddCommand(IndexCmd, LanguageServerCmd, CompletionCmd, DevCmds)\n\n\terr := rootCmd.Execute()\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tos.Exit(1)\n\t}\n}\n\nfunc startLsp(lsp *LanguageServerConfig, clientConn *protocol.Client, params *protocol.InitializeParams) (*ChildLanguageServer, error) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcmd := exec.Command(*lsp.Command, lsp.Args...)\n\tstdin, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tworkspaceDir := getWorkspaceDir(wd)\n\tstdoutFileName := filepath.Join(workspaceDir, \"lsp_stdout.log\")\n\tstdoutFile, err := os.Create(stdoutFileName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstdinFileName := filepath.Join(workspaceDir, \"lsp_stdin.log\")\n\tstdinFile, err := os.Create(stdinFileName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstderrFileName := filepath.Join(workspaceDir, \"lsp_stderr.log\")\n\tstderrFile, err := os.Create(stderrFileName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgo func() {\n\t\tstderrScanner := bufio.NewScanner(stderr)\n\t\tfor stderrScanner.Scan() {\n\t\t\t_, err := stderrFile.Write(stderrScanner.Bytes())\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tstderrFile.Sync()\n\t\t}\n\n\t\terr := stderrFile.Close()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tjsonRpcLogFile := filepath.Join(workspaceDir, \"json_rpc.log\")\n\tjsonRpcLog, err := os.Create(jsonRpcLogFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tencoderConfig := zap.NewProductionEncoderConfig()\n\tencoderConfig.TimeKey = \"timestamp\"\n\tencoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder\n\tcore := zapcore.NewCore(\n\t\tzapcore.NewJSONEncoder(encoderConfig), // Encoder configuration\n\t\tzapcore.AddSync(jsonRpcLog),           // Log file\n\t\tzap.DebugLevel,                        // Log level\n\t)\n\n\t// Create the logger\n\tlogger := zap.New(core)\n\n\trwc := &CombinedReadWriteCloser{\n\t\tReader: stdout,\n\t\tWriter: stdin,\n\t\tCloser: func() error {\n\t\t\terr2 := stdin.Close()\n\t\t\terr1 := stdout.Close()\n\t\t\tif err1 != nil || err2 != nil {\n\t\t\t\treturn fmt.Errorf(\"Stdout:(%w) Stdin:(%w)\", err1, err2)\n\t\t\t}\n\n\t\t\treturn cmd.Process.Kill()\n\t\t},\n\t\treadFile:  stdoutFile,\n\t\twriteFile: stdinFile,\n\t}\n\tstream := jsonrpc2.NewStream(rwc)\n\tconn := jsonrpc2.NewConn(stream)\n\n\tif clientConn == nil {\n\t\tlspClient := protocol.ClientDispatcher(conn, logger)\n\t\tclientConn = &lspClient\n\t}\n\n\tctx, conn, server := protocol.NewClient(context.Background(), *clientConn, stream, zap.L())\n\n\tresult, err := server.Initialize(ctx, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchildLs := &ChildLanguageServer{\n\t\tConn:    conn,\n\t\tCmd:     cmd,\n\t\tServer:  server,\n\t\tContext: ctx,\n\t\tClose: func() {\n\t\t\tlogger.Sync()\n\t\t\tjsonRpcLog.Close()\n\t\t\tstdoutFile.Close()\n\t\t\tstdinFile.Close()\n\t\t\tstderrFile.Close()\n\t\t\tconn.Close()\n\t\t},\n\t\tInitResult: result,\n\t}\n\n\tgo func() {\n\t\tcmd.Wait()\n\t}()\n\n\treturn childLs, nil\n}\n\n\n```\n\n",
      "name": "potential_context"
    },
    {
      "role": "user",
      "content": "Here is a short summary of our conversation so far:\nThe conversation involves a human asking the assistant about a specific Go code snippet and its functionality. The assistant provides a detailed breakdown of the code, explaining that it is part of a larger application that interacts with Language Servers, offering features like indexing, code completion, and development tools through a command-line interface. The code snippet defines various command definitions related to managing models, contexts, and configurations within the application. It also includes functions for executing these commands, handling progress updates, and generating code completions based on user prompts. The conversation ends with the human requesting further information about the code snippet.\n"
    },
    {
      "role": "user",
      "content": "What does this code do?"
    },
    {
      "role": "assistant",
      "content": "This Go code is part of a larger application that, among other functionalities, includes the ability to start and manage a Language Server Protocol (LSP) server. Here's a breakdown of its main components and functionalities:\n\n1. **Package and Imports**: The code is part of the `main` package and imports several Go packages for handling file operations, executing commands, logging, and working with the Language Server Protocol (LSP) and JSON-RPC.\n\n2. **SymbolInfo Struct**: Defines a `SymbolInfo` struct that extends the `protocol.SymbolInformation` with additional fields like `RelativePath`, `Description`, and `Embedding`. This struct likely represents enhanced symbol information for use within the application.\n\n3. **main Function**: Sets up a CLI (Command Line Interface) using the Cobra library. It defines the root command and adds several subcommands (`IndexCmd`, `LanguageServerCmd`, `CompletionCmd`, `DevCmds`). It executes the root command and handles any errors that occur during its execution.\n\n4. **startLsp Function**: This function is responsible for starting a Language Server based on the provided configuration. It performs several steps:\n   - Determines the current working directory.\n   - Prepares the command to start the LSP server using the provided configuration.\n   - Sets up logging for the LSP's standard input, output, and error streams by creating files in a workspace directory.\n   - Starts the LSP server process.\n   - Configures logging for JSON-RPC communication between the client and the server.\n   - Creates a `CombinedReadWriteCloser` to manage the LSP server's input and output streams, along with the necessary file logging.\n   - Establishes a JSON-RPC connection over these streams.\n   - Optionally replaces the default client connection with a custom one if provided.\n   - Initializes the LSP server using the provided initialization parameters and handles any errors.\n   - Returns a `ChildLanguageServer` instance, which contains references to the server process, the JSON-RPC connection, and other relevant information, along with a method to cleanly shut down the server and its associated resources.\n\nOverall, this code is part of a tool that interacts with Language Servers, providing functionalities like indexing, code completion, and other development tools through a command-line interface. The `startLsp` function, in particular, is focused on starting and managing an LSP server process, handling its input/output streams, and setting up logging for both the server's operation and the JSON-RPC communication."
    },
    {
      "role": "user",
      "content": "```go:code_actions.go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"go.lsp.dev/protocol\"\n\t\"go.lsp.dev/uri\"\n)\n\nvar lspCommands = []*CommandDefinition{\n\tlspCommandExecCompletion,\n\tlspCommandOpenModelsConfig,\n\tlspCommandOpenContextConfig,\n\tlspCommandShowCurrentContext,\n\tlspCommandShowCurrentModel,\n}\n\nfunc getPositionOffset(text string) protocol.Position {\n\tnewLines := strings.Count(text, \"\\n\")\n\tvar cols = len(text)\n\tif newLines > 0 {\n\t\tspl := strings.Split(text, \"\\n\")\n\t\tcols = len(spl[newLines])\n\t}\n\n\treturn protocol.Position{\n\t\tLine:      uint32(newLines),\n\t\tCharacter: uint32(cols),\n\t}\n}\n\nvar lspCommandShowCurrentModel = &CommandDefinition{\n\tTitle:          \"Show current Ollama model\",\n\tShowCodeAction: false,\n\tIdentifier:     \"sage.workspace.configuration.model\",\n\tBuildArgs: func(params *protocol.CodeActionParams) ([]any, error) {\n\t\treturn []any{}, nil\n\t},\n\tExecute: func(params *protocol.ExecuteCommandParams, client LspClient, clientInfo *LanguageServerClientInfo) (*protocol.ApplyWorkspaceEditParams, error) {\n\t\tclient.Progress(context.TODO(), &protocol.ProgressParams{\n\t\t\t// Token: *params.WorkDoneProgressParams.WorkDoneToken,\n\t\t\tValue: &protocol.WorkDoneProgressBegin{\n\t\t\t\tKind:    protocol.WorkDoneProgressKindBegin,\n\t\t\t\tTitle:   \"Ollama model\",\n\t\t\t\tMessage: \"getting model...\",\n\t\t\t},\n\t\t})\n\n\t\tmodels, err := clientInfo.Config.Models.Get()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tclient.Progress(context.TODO(), &protocol.ProgressParams{\n\t\t\t// Token: *params.WorkDoneProgressParams.WorkDoneToken,\n\t\t\tValue: &protocol.WorkDoneProgressEnd{\n\t\t\t\tKind:    protocol.WorkDoneProgressKindEnd,\n\t\t\t\tMessage: *models.Default,\n\t\t\t},\n\t\t})\n\n\t\treturn nil, nil\n\t},\n}\n\nvar lspCommandShowCurrentContext = &CommandDefinition{\n\tTitle:          \"Show context\",\n\tShowCodeAction: false,\n\tIdentifier:     \"sage.workspace.context.show\",\n\tBuildArgs: func(params *protocol.CodeActionParams) ([]any, error) {\n\t\treturn []any{}, nil\n\t},\n\tExecute: func(params *protocol.ExecuteCommandParams, client LspClient, clientInfo *LanguageServerClientInfo) (*protocol.ApplyWorkspaceEditParams, error) {\n\t\tproviders, err := clientInfo.Config.Context.Get()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tllmContext, err := BuildContext(providers, clientInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tf, err := os.CreateTemp(os.TempDir(), \"sage_context\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t_, err = f.WriteString(llmContext)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfilename := f.Name()\n\n\t\tf.Close()\n\n\t\tresult := &protocol.ShowDocumentResult{}\n\t\t_, err = client.Conn().Call(context.TODO(), string(protocol.MethodShowDocument), protocol.ShowDocumentParams{\n\t\t\tURI:       uri.File(filename),\n\t\t\tExternal:  false,\n\t\t\tTakeFocus: true,\n\t\t\tSelection: nil,\n\t\t}, result)\n\n\t\treturn nil, err\n\t},\n}\n\nvar lspCommandOpenContextConfig = &CommandDefinition{\n\tTitle:          \"Edit context\",\n\tShowCodeAction: true,\n\tIdentifier:     \"sage.workspace.context.edit\",\n\tBuildArgs: func(params *protocol.CodeActionParams) ([]any, error) {\n\t\treturn []any{}, nil\n\t},\n\tExecute: func(params *protocol.ExecuteCommandParams, client LspClient, clientInfo *LanguageServerClientInfo) (*protocol.ApplyWorkspaceEditParams, error) {\n\t\tresult := &protocol.ShowDocumentResult{}\n\t\t_, err := client.Conn().Call(context.TODO(), string(protocol.MethodShowDocument), protocol.ShowDocumentParams{\n\t\t\tURI:       uri.File(getWorkspaceContextPath()),\n\t\t\tExternal:  false,\n\t\t\tTakeFocus: true,\n\t\t\tSelection: nil,\n\t\t}, result)\n\n\t\treturn nil, err\n\t},\n}\n\nvar lspCommandOpenModelsConfig = &CommandDefinition{\n\tTitle:          \"Edit workspace configuration\",\n\tShowCodeAction: true,\n\tIdentifier:     \"sage.workspace.configuration.edit\",\n\tBuildArgs: func(params *protocol.CodeActionParams) ([]any, error) {\n\t\treturn []any{}, nil\n\t},\n\tExecute: func(params *protocol.ExecuteCommandParams, client LspClient, clientInfo *LanguageServerClientInfo) (*protocol.ApplyWorkspaceEditParams, error) {\n\t\tresult := &protocol.ShowDocumentResult{}\n\t\t_, err := client.Conn().Call(context.TODO(), string(protocol.MethodShowDocument), protocol.ShowDocumentParams{\n\t\t\tURI:       uri.File(getWorkspaceModelsPath()),\n\t\t\tExternal:  false,\n\t\t\tTakeFocus: true,\n\t\t\tSelection: nil,\n\t\t}, result)\n\n\t\treturn nil, err\n\t},\n}\n\nvar lspCommandExecCompletion = &CommandDefinition{\n\tTitle:          \"Ollama generate\",\n\tShowCodeAction: true,\n\tIdentifier:     \"sage.completion.selection\",\n\tBuildArgs: func(params *protocol.CodeActionParams) ([]any, error) {\n\t\targs := &LlmCompletionArgs{\n\t\t\tFilename:  params.TextDocument.URI,\n\t\t\tSelection: params.Range,\n\t\t}\n\n\t\treturn []any{args}, nil\n\t},\n\tExecute: func(params *protocol.ExecuteCommandParams, client LspClient, clientInfo *LanguageServerClientInfo) (*protocol.ApplyWorkspaceEditParams, error) {\n\t\tlsLogger := globalLsLogger.With().Str(\"code_action\", \"sage.completion.selection\").Logger()\n\t\targBs, err := json.Marshal(params.Arguments[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\targs := &LlmCompletionArgs{}\n\t\terr = json.Unmarshal(argBs, args)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttextDocument := clientInfo.GetOpenDocument(args.Filename)\n\n\t\tdocumentLines := append(strings.Split(textDocument.Text, \"\\n\"), \"\") // Unixy files end in \\n\n\t\tlineRange := documentLines[args.Selection.Start.Line : args.Selection.End.Line+1]\n\t\tlsLogger.Debug().Str(\"Line range\", fmt.Sprint(lineRange)).Msg(\"Lines Range\")\n\t\tendLineIndex := args.Selection.End.Line - args.Selection.Start.Line\n\t\tlsLogger.Debug().Uint32(\"end idx\", endLineIndex).Msg(\"End idx\")\n\t\tlineRange[0] = lineRange[0][args.Selection.Start.Character:]\n\t\tlineRange[endLineIndex] = lineRange[endLineIndex][:args.Selection.End.Character]\n\t\tlsLogger.Debug().Str(\"Line range\", fmt.Sprint(lineRange)).Msg(\"Lines Range after narrowing\")\n\n\t\tdocumentContext := strings.Join(documentLines[:args.Selection.End.Line], \"\\n\")\n\t\tselectionText := strings.Join(lineRange, \"\\n\")\n\n\t\tcontextProviders, err := clientInfo.Config.Context.Get()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfilesContext, err := BuildContext(contextProviders, clientInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tprompt := filesContext\n\n\t\tprompt += \"<CurrentFile path=\\\"\" + args.Filename.Filename() + \"\\\">\\n\"\n\t\tprompt += documentContext\n\t\tprompt += \"\\n</CurrentFile>\\n\"\n\n\t\tprompt += `<SystemPrompt>\nA user's prompt, in the form of a question, or a description code to write, is shown below. Satisfy the user's prompt or question to the best of your ability. If asked to complete code, DO NOT type out any extra text, or backticks since your response will be appended to the end of the CurrentFile. DO NOT regurgitate the whole file. Simply return the new code, or the modified code.\n</SystemPrompt>\n`\n\n\t\tprompt += \"<UserPrompt>\\n\"\n\t\tprompt += selectionText\n\t\tprompt += \"\\n</UserPrompt>\\n\"\n\n\t\tcompletionCh := make(chan string)\n\t\terrCh := make(chan error)\n\n\t\tvar receiveCompletionFunc GenerateResponseFunc = func(cr CompletionResponse) error {\n\t\t\tlsLogger.Debug().Str(\"text\", cr.Text).Bool(\"done\", cr.Done).Msg(\"Received text\")\n\t\t\tcompletionCh <- cr.Text\n\t\t\tif cr.Done {\n\t\t\t\tclose(completionCh)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\tmodels, err := clientInfo.Config.Models.Get()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tmodel := *models.Default\n\n\t\tlsLogger.Info().Str(\"model\", model).Str(\"prompt\", prompt).Msg(\"Generating completion\")\n\n\t\tclient.Progress(context.TODO(), &protocol.ProgressParams{\n\t\t\t// Token: *params.WorkDoneProgressParams.WorkDoneToken,\n\t\t\tValue: &protocol.WorkDoneProgressBegin{\n\t\t\t\tKind:    protocol.WorkDoneProgressKindBegin,\n\t\t\t\tTitle:   \"Sage completion\",\n\t\t\t\tMessage: \"connecting...\",\n\t\t\t},\n\t\t})\n\n\t\tgo func() {\n\t\t\terr := clientInfo.LLM.StreamCompletion(context.TODO(), model, prompt, receiveCompletionFunc)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t}\n\n\t\t\tclose(errCh)\n\t\t}()\n\n\t\tfullText := \"\"\n\t\tcurrentLine := \"\"\n\n\t\tplaceNextEdit := protocol.Position{\n\t\t\tLine:      args.Selection.End.Line,\n\t\t\tCharacter: args.Selection.End.Character,\n\t\t}\n\n\touter:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase nextText, ok := <-completionCh:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak outer\n\t\t\t\t}\n\n\t\t\t\tfullText += nextText\n\n\t\t\t\tif strings.Contains(nextText, \"\\n\") {\n\t\t\t\t\tspl := strings.Split(nextText, \"\\n\")\n\t\t\t\t\tcurrentLine += spl[0]\n\n\t\t\t\t\tlsLogger.Debug().Str(\"line\", currentLine).Msg(\"Logging completion line to editor\")\n\t\t\t\t\tclient.Progress(context.TODO(), &protocol.ProgressParams{\n\t\t\t\t\t\t// Token: *params.WorkDoneProgressParams.WorkDoneToken,\n\t\t\t\t\t\tValue: &protocol.WorkDoneProgressReport{\n\t\t\t\t\t\t\tKind:    protocol.WorkDoneProgressKindReport,\n\t\t\t\t\t\t\tMessage: \"sage: \" + currentLine,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\tcurrentLine = strings.Join(spl[1:], \"\\n\")\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += nextText\n\t\t\t\t}\n\n\t\t\t\t// Live edits code\n\n\t\t\t\tclient.ApplyEdit(context.TODO(), &protocol.ApplyWorkspaceEditParams{\n\t\t\t\t\tLabel: \"llm_line\",\n\t\t\t\t\tEdit: protocol.WorkspaceEdit{\n\t\t\t\t\t\tChanges: map[uri.URI][]protocol.TextEdit{\n\t\t\t\t\t\t\targs.Filename: []protocol.TextEdit{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tRange: protocol.Range{\n\t\t\t\t\t\t\t\t\t\tStart: placeNextEdit,\n\t\t\t\t\t\t\t\t\t\tEnd:   placeNextEdit,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tNewText: nextText,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\toffset := getPositionOffset(nextText)\n\t\t\t\tplaceNextEdit.Line += offset.Line\n\t\t\t\tplaceNextEdit.Character += offset.Character\n\t\t\t\tif offset.Line > 0 {\n\t\t\t\t\tplaceNextEdit.Character = offset.Character\n\t\t\t\t}\n\t\t\tcase err, ok := <-errCh:\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tclose(completionCh)\n\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tlsLogger.Debug().Str(\"completion\", fullText).Msg(\"Returning completion\")\n\t\tclient.Progress(context.TODO(), &protocol.ProgressParams{\n\t\t\t// Token: *params.WorkDoneProgressParams.WorkDoneToken,\n\t\t\tValue: &protocol.WorkDoneProgressEnd{\n\t\t\t\tKind:    protocol.WorkDoneProgressKindEnd,\n\t\t\t\tMessage: \"Done!\",\n\t\t\t},\n\t\t})\n\n\t\treturn nil, nil\n\n\t\t// return &protocol.ApplyWorkspaceEditParams{\n\t\t// \tLabel: \"LLM completion\",\n\t\t// \tEdit: protocol.WorkspaceEdit{\n\t\t// \t\tChanges: map[uri.URI][]protocol.TextEdit{\n\t\t// \t\t\targs.Filename: []protocol.TextEdit{\n\t\t// \t\t\t\t{\n\t\t// \t\t\t\t\t// We want to put the completion right after the selection\n\t\t// \t\t\t\t\tRange: protocol.Range{\n\t\t// \t\t\t\t\t\tStart: args.Selection.End,\n\t\t// \t\t\t\t\t\tEnd:   args.Selection.End,\n\t\t// \t\t\t\t\t},\n\t\t// \t\t\t\t\tNewText: fullText,\n\t\t// \t\t\t\t},\n\t\t// \t\t\t},\n\t\t// \t\t},\n\t\t// \t},\n\t\t// }, nil\n\t},\n}\n\n```\n@code_actions.go given this new context, what else can you tell me?"
    },
    {
      "role": "assistant",
      "content": "Given the detailed context of `code_actions.go`, this Go file is part of a larger application that integrates with the Language Server Protocol (LSP) to provide various code actions within a development environment. The file defines a series of commands (`lspCommands`) that can be executed within this environment, each encapsulated by a `CommandDefinition` struct. Here's a closer look at the key components and functionalities:\n\n### CommandDefinition Struct\n- **Title**: A human-readable title for the command.\n- **ShowCodeAction**: A boolean indicating whether the command should be shown as a code action in the UI.\n- **Identifier**: A unique identifier for the command.\n- **BuildArgs**: A function that builds the arguments required to execute the command, based on the parameters of a code action request.\n- **Execute**: The function that is called to execute the command. It takes the command parameters, an LSP client interface, and client information as arguments and returns an `ApplyWorkspaceEditParams` object or an error.\n\n### Commands\n1. **lspCommandExecCompletion**: Generates and applies code completions based on the current context and user selection.\n2. **lspCommandOpenModelsConfig**: Opens the configuration file for models, allowing the user to edit it.\n3. **lspCommandOpenContextConfig**: Opens the context configuration file for editing.\n4. **lspCommandShowCurrentContext**: Shows the current context information, potentially by creating a temporary file and displaying its contents.\n5. **lspCommandShowCurrentModel**: Displays the currently active model configuration.\n\n### Key Functionalities\n- **Contextual Actions**: The commands are designed to interact with the user's workspace and editing context, such as showing or editing configurations and generating completions based on the current context.\n- **Integration with LSP**: The commands make use of the LSP for executing actions like showing documents or applying workspace edits, indicating tight integration with the LSP to enhance the development environment.\n- **Dynamic Execution**: The `Execute` function of each command dynamically interacts with the development environment, performing actions like generating completions, opening configuration files, and displaying progress to the user.\n- **Error Handling**: Commands handle errors gracefully, returning them to the caller, which allows for robust execution and error reporting within the LSP client.\n\n### Conclusion\nThis file is a sophisticated part of an LSP-integrated tool, designed to enhance the development experience by providing context-aware actions directly within the editor. It leverages the LSP and custom logic to offer functionalities like editing configuration files, showing context or model information, and generating code completions, all aimed at improving productivity and providing a seamless development workflow."
    },
    {
      "role": "user",
      "content": "```go:llm_context.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype ContextItemGetterFunc func(ContextApi) (*ContextItem, error)\n\ntype ContextItemType string\n\nconst (\n\tContextItemTypeFile   ContextItemType = \"file\"\n\tContextItemTypeSymbol ContextItemType = \"symbol\"\n\tContextItemTypeRange  ContextItemType = \"range\"\n)\n\ntype ContextApi interface {\n\tGetSymbol(filename string, symbolName string) (string, error)\n\tGetRange(filename string, start, end int) (string, error)\n\tGetFile(filename string) (string, error)\n}\n\ntype ContextItem struct {\n\tFilename   string\n\tIdentifier string // Line number range or symbol name\n\tContent    string\n}\n\ntype ContextItemProvider struct {\n\tparts    []string\n\titemType ContextItemType\n\tgetter   ContextItemGetterFunc\n}\n\nfunc (cip *ContextItemProvider) Type() ContextItemType {\n\treturn cip.itemType\n}\n\nfunc (cip *ContextItemProvider) String() string {\n\treturn strings.Join(cip.parts, \" \")\n}\n\nfunc (cip *ContextItemProvider) GetItem(api ContextApi) (*ContextItem, error) {\n\treturn cip.getter(api)\n}\n\nfunc ParseContext(contextDefinition string) ([]*ContextItemProvider, error) {\n\tscanner := bufio.NewScanner(strings.NewReader(contextDefinition))\n\tscanner.Split(bufio.ScanLines)\n\n\tvar providers []*ContextItemProvider\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tnewProviders, err := parseContextLine(line)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error for line '%s': %w\", line, err)\n\t\t}\n\n\t\tproviders = append(providers, newProviders...)\n\t}\n\n\treturn providers, nil\n}\n\nfunc getLineParts(line string) ([]string, error) {\n\tvar parts []string\n\n\tvar currentPart strings.Builder\n\n\tvar inQuotes bool\n\tvar escaped bool\n\n\tfor _, char := range line {\n\t\tswitch {\n\t\tcase escaped:\n\t\t\tcurrentPart.WriteRune(char)\n\t\t\tescaped = false\n\t\tcase char == '\\\\':\n\t\t\tescaped = true\n\t\tcase char == '\"' && !escaped:\n\t\t\tinQuotes = !inQuotes\n\n\t\t\tif !inQuotes {\n\t\t\t\tparts = append(parts, currentPart.String())\n\t\t\t\tcurrentPart.Reset()\n\t\t\t}\n\n\t\tcase char == ' ' && !inQuotes:\n\t\t\tif currentPart.Len() > 0 {\n\t\t\t\tparts = append(parts, currentPart.String())\n\t\t\t\tcurrentPart.Reset()\n\t\t\t}\n\t\tdefault:\n\t\t\tcurrentPart.WriteRune(char)\n\t\t}\n\t}\n\n\tif currentPart.Len() > 0 {\n\t\tparts = append(parts, currentPart.String())\n\t}\n\n\tif inQuotes {\n\t\treturn nil, fmt.Errorf(\"Found quote with no matching closing quote\")\n\t}\n\n\treturn parts, nil\n}\n\nfunc parseRange(rangeStr string) (start, end int, err error) {\n\tparts := strings.Split(rangeStr, \":\")\n\tif len(parts) != 2 {\n\t\treturn 0, 0, fmt.Errorf(\"Found range with >2 parts: '%s'\", rangeStr)\n\t}\n\n\tstart, err = strconv.Atoi(parts[0])\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"Invalid start of range '%s': %w\", parts[0], err)\n\t}\n\n\tend, err = strconv.Atoi(parts[1])\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"Invalid end of range '%s': %w\", parts[1], err)\n\t}\n\n\tif start > end {\n\t\treturn 0, 0, fmt.Errorf(\"Start cannot be greater than end of range '%s'\", rangeStr)\n\t}\n\n\treturn\n}\n\nfunc parseContextLine(line string) ([]*ContextItemProvider, error) {\n\tif line == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tparts, err := getLineParts(line)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar providers []*ContextItemProvider\n\n\tfilename := parts[0]\n\n\t// Our options right now are a whole file, a file range, or a symbol.\n\t// Each row can have one filename, but multiple options for symbols or line ranges\n\tif len(parts) == 1 {\n\t\tproviders = append(providers, &ContextItemProvider{\n\t\t\tparts:    parts,\n\t\t\titemType: ContextItemTypeFile,\n\t\t\tgetter: func(ca ContextApi) (*ContextItem, error) {\n\t\t\t\tcontent, err := ca.GetFile(filename)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\treturn &ContextItem{\n\t\t\t\t\tFilename:   filename,\n\t\t\t\t\tIdentifier: \"\",\n\t\t\t\t\tContent:    content,\n\t\t\t\t}, nil\n\t\t\t},\n\t\t})\n\n\t\treturn providers, nil\n\t}\n\n\t// We have more than one item for this file\n\n\tfor _, item := range parts[1:] {\n\t\titemType := ContextItemTypeSymbol\n\t\tvar getItem ContextItemGetterFunc = func(ca ContextApi) (*ContextItem, error) {\n\t\t\tcontent, err := ca.GetSymbol(filename, item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &ContextItem{\n\t\t\t\tFilename:   filename,\n\t\t\t\tIdentifier: item,\n\t\t\t\tContent:    content,\n\t\t\t}, nil\n\t\t}\n\n\t\tif strings.Contains(item, \":\") {\n\t\t\titemType = ContextItemTypeRange\n\t\t\tstart, end, err := parseRange(item)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tgetItem = func(ca ContextApi) (*ContextItem, error) {\n\t\t\t\tcontent, err := ca.GetRange(filename, start, end)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\treturn &ContextItem{\n\t\t\t\t\tFilename:   filename,\n\t\t\t\t\tIdentifier: fmt.Sprintf(\"%d:%d\", start, end),\n\t\t\t\t\tContent:    content,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\n\t\tproviders = append(providers, &ContextItemProvider{\n\t\t\tparts:    parts,\n\t\t\titemType: itemType,\n\t\t\tgetter:   getItem,\n\t\t})\n\t}\n\n\treturn providers, nil\n}\n\nfunc BuildContext(providers []*ContextItemProvider, api ContextApi) (string, error) {\n\tvar builder strings.Builder\n\n\tfor _, provider := range providers {\n\t\tvar tagName string\n\n\t\tcontextItem, err := provider.GetItem(api)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\ttagParams := map[string]string{\n\t\t\t\"file\": contextItem.Filename,\n\t\t}\n\n\t\tswitch provider.Type() {\n\t\tcase ContextItemTypeFile:\n\t\t\ttagName = \"File\"\n\t\tcase ContextItemTypeRange:\n\t\t\ttagName = \"FileRange\"\n\t\t\ttagParams[\"range\"] = contextItem.Identifier\n\t\tcase ContextItemTypeSymbol:\n\t\t\ttagName = \"FileSymbol\"\n\t\t\ttagParams[\"symbol\"] = contextItem.Identifier\n\t\tdefault:\n\t\t\treturn \"\", fmt.Errorf(\"Invalid item type '%s'\", provider.Type())\n\t\t}\n\n\t\tbuilder.WriteString(\"<\" + tagName + \"\\n\")\n\t\tfor k, v := range tagParams {\n\t\t\t_, err = builder.WriteString(fmt.Sprintf(\"%s=\\\"%s\\\"\\n\", k, v))\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\tbuilder.WriteString(\">\\n\")\n\t\tbuilder.WriteString(contextItem.Content)\n\t\tbuilder.WriteString(\"\\n\")\n\t\tbuilder.WriteString(\"</\" + tagName + \">\\n\")\n\t}\n\n\treturn builder.String(), nil\n}\n\n```\nhow does this file @llm_context.go play into it?"
    },
    {
      "role": "assistant",
      "content": "The `llm_context.go` file is a crucial component of the larger application, specifically designed to manage and construct context for language model (LLM) operations, such as generating code completions or other AI-driven tasks. It defines structures and functions for parsing, representing, and retrieving various types of context from a development environment. Here's how it integrates and contributes to the overall functionality:\n\n### Key Components\n\n1. **ContextItemGetterFunc**: A function type that takes a `ContextApi` and returns a `ContextItem` and an error. It's used to abstract the retrieval of different types of context items (files, symbols, ranges) from the development environment.\n\n2. **ContextItemType**: An enumeration (`const`) that defines the types of context items supported (`file`, `symbol`, `range`).\n\n3. **ContextApi Interface**: Defines the contract for an API that can retrieve context information from the development environment, such as symbols, ranges, or entire files.\n\n4. **ContextItem**: Represents a piece of context, including the filename, an identifier (which could be a line number range or a symbol name), and the content itself.\n\n5. **ContextItemProvider**: Encapsulates the logic for retrieving a specific type of context item. It includes the item type, a getter function, and a string representation.\n\n### Functionalities\n\n- **ParseContext**: Parses a context definition string into a list of `ContextItemProvider` instances. This allows for dynamic construction of context based on a textual representation, which could be user-defined or generated by another part of the application.\n\n- **BuildContext**: Takes a list of `ContextItemProvider` instances and an implementation of `ContextApi` to construct a comprehensive context string. This string could be used as input to a language model for generating code completions, suggestions, or other AI-driven code manipulations.\n\n### Integration with the Larger Application\n\n- The `BuildContext` function is likely called by the larger application (as seen in `code_actions.go`) to generate context for operations like code completion. This context includes information about the current file, selected text, and other relevant data that helps the language model understand the task at hand.\n\n- The `ContextApi` interface is implemented by parts of the application that interact with the development environment, providing a way to retrieve necessary context information like file contents, symbol definitions, or specific code ranges.\n\n- The dynamic nature of `ContextItemProvider` allows for flexible context construction, supporting various types of information that might be relevant for different tasks or language models.\n\n### Conclusion\n\n`llm_context.go` plays a foundational role in managing and providing context for AI-driven features within the application. By abstracting the retrieval and representation of context, it enables the application to dynamically generate rich, detailed inputs for language models, thereby enhancing the capabilities and effectiveness of code generation, completion, and other AI-powered functionalities."
    },
    {
      "role": "user",
      "content": "from the code you analyzed?, can you give me an example of the types of context definitions that might be supported?"
    }
  ],
  "temperature": 0,
  "user": "ca6f0ddded68ef2b7149807e03f2515f",
  "stream": true
}
